#pragma once

#include "TSharpParserBaseListener.h"

#include <string>
#include <map>

#include "Object.h"

class TSharpExecListener : public TSharpParserBaseListener
{
private:
    // Private member variables - stores state as maps of name, against type of entity being stored
    std::map<std::string, int> Integers;
    std::map<std::string, std::string> Strings;
    std::map<std::string, char> Chars;
    std::map<std::string, float> Floats;
    std::map<std::string, double> Doubles;
    std::map<std::string, Object> Objects;
    
    // Is executing state
    bool isExecuting;
    
    // Helper to create strings
    void createString(const std::string& name, const std::string& value) noexcept
    {
        Strings[name] = value;
    }
    
    // Helper to create integers
    void createInt(const std::string& name, int value) noexcept
    {
        Integers[name] = value;
    }
    
public:
    // Constructor, initialize all maps as empty maps
    TSharpExecListener() noexcept : Integers{}, Strings{}, Chars{}, Floats{}, Doubles{}, Objects{}, isExecuting(true)
    {}
    
    // Enter assignment e.g. int x = 0 (inherited from TSharpParserBaseListener - which is generated by ANTLR)
    void enterAssignment(TSharpParser::AssignmentContext* ctx) override
    {
        if (ctx->type_of->getText() == "string")
        {
            createString(ctx->name->getText(), ctx->val->getText());
        }
        
        else if (ctx->type_of->getText() == "int")
        {
            createInt(ctx->name->getText(), std::stoi(ctx->val->getText()));
        }
    }
    
    // Enter println statement e.g. println("Hello World") (inherited from TSharpParserBaseListener - which is generated by ANTLR)
    void enterPrintln_statement(TSharpParser::Println_statementContext* ctx) override
    {
        // If message is a raw string
        if (ctx->msg->getText().find(""""))
        {
            std::string s = ctx->msg->getText();
            
            s.erase(
                std::remove( s.begin(), s.end(), '\"' ),
                s.end()
            );
            
            std::cout << s << std::endl;
        }
        
        // If message is an identifier (an assigned variable)
        else
        {
            std::string s = Strings[ctx->msg->getText()];
            
            s.erase(
                std::remove( s.begin(), s.end(), '\"' ),
                s.end()
            );
            
            std::cout << s << std::endl;
        }
    }
    
    
    // Enter class e.g. class A {} (inherited from TSharpParserBaseListener - which is generated by ANTLR)
    void enterClass(TSharpParser::ClassContext* ctx) override
    {
        std::string obj = ctx->name->getText();
        
        Objects.emplace(obj, Object(obj));
    }
    
    // Enter field e.g. private string _s (inherited from TSharpParserBaseListener - which is generated by ANTLR)
    void enterField(TSharpParser::FieldContext* ctx) override
    {
        // TODO: Better way of getting class name for a field declaration, current way is shit
        std::string s = ctx->parent->getText();
        std::string delim = "class";
        std::string delim2 = "{";
        std::string class_name = s.erase(0, s.find(delim) + delim.length());
        class_name = class_name.substr(0, class_name.find("{"));
        
        Objects.at(class_name).addString(ctx->name->getText(), "", ctx->access->getText() == "private" ? true : false);
    }
    
    // Enter constructor e.g. public A() {} (inherited from TSharpParserBaseListener - which is generated by ANTLR)
    // void enterConstructor(TSharpParser::ConstructorContext* ctx) override
    // {
    //    Objects.at(ctx->name->getText()).addConstructor(Constructor(ctx->access->getText() == "private" ? true : false));
    // }
    
    void enterClass_instantiation(TSharpParser::Class_instantiationContext* ctx) override
    {
        std::string class_name = ctx->class_name->getText();
        std::string obj_name = ctx->name->getText();
        auto args = ctx->vals->getText();
        
        Objects.emplace(obj_name, Object(obj_name));
        
        //Objects.at(class_name).callConstructor(args);
        
    }
};
